Notes to the assessor. 

This file will contain my musings/workings for your convenience and will act a stream of conciousnes.
I took the liberty to upgrade the project to core 3.1. having spoken with Callum, I *think* this is used in the FinTech team - so I hope this is ok

- Story 1. 
	- Will assume that JG.FinTechTest can be renamed for this solutiuon, to encapsulate the gift aid domain.
		I do hope this is ok - the readme for the test makes no mention of items which *must* remain untouched.
	- I would image in a more real world scenario, FinTech would comprise of several "domains" (e.g. PaymentProcesing, Payouts), of which GiftAid is one

	- TDD approach taken to creating the calculator
	- I've started off putting the calculator in its own project. 
		In the "real world" this might be a useful thing to do if calculations are complex enough to warrant it.. and would manifest itself as a Nuget package.
		I'm aware that for the purposes of this submission it might be overkill. I might change tack later on.
	- Looks like the tax rate is always against basic rate tax for Gift aid. 
		https://justgiving-charity-support.zendesk.com/hc/en-us/articles/204663747-Understanding-Gift-Aid-UK-Only-#:~:text=Under%20HMRC%27s%20Gift%20Aid%20scheme,that%20taxpayer%20on%20that%20donation.&text=The%20fraction%20applied%20to%20calculate,100%20which%20equals%20£25.
		However, UK basic tax rates can change and this might not always be exclusive to the UK, so this won't be hard coded
	- Initially, I assumed that Tax rates will be whole percentage numbers and never decimals. 
		However, after some research, Denmark and Egypt are examples of countries with a fracional percentage on basic rate tax. 
		No reason why this couldn't be a thing in the UK either. As such the signature is a decimal	for tax rate.
	- We will assume we want to return a value to the penny, (2 d.p)
	- We will assume we can round UP to the penny, when the whole penny is the nearest rounded value.
		We could make the calculator more dynamic in its behaviour, with round up and round down semantics, but in the interests of time for this test I won't do this.'

- Story 2
	- Looks like NSWAG is our friend. I've never used nswag to "reverse generate" a controller before - this is cool!
	- It took me a while to figure out how to do it, but swagger.yaml will generate the controller now which is great. 
		I'm sure there could be options to split the interfaces and the autogenerated code into separate files, but for now I'll leave this as is in the interests of time.
	- I'll create an Implementations folder for the contoller
	- Used Autofac to inject Implementaiton of the controller and calculator.
	- I've noticed the swagger.yaml specifies doubles in the signatures. 
		We will assume that this is because many other languages don't have decimal. We will adhere to the contract, casting where necessary but using decimals internally
	- Also noticed that tax rate is not sent to the API, and that the API itself must dictate what the tax rate is. 
		I'm going to make this configurable and to avoid the calculator being aware of any configuration, this will be injected into the module.
		As such, the calculator will change to take a tax rate in its constructor.
		This leads me to question where tax rate validation should then go. I'm going to move this into the constructor, with the awareness that a "misconfiguration" would cause the API to not come up.
		I think it's correct for the calculator to validate its dependencies in the constructor.
	- On my travels I noticed my testing fow the calculator didn't test or have validation on the donation amount	
	- I've not used NSubstitute before (usually moq) so apologies if I don't pick the most appropriate usage.
		It's actually quite nice to use!
	- Created unit tests to assert calls made in controller
	- Created integration tests to resolve all controller interfaces (which are autogenerated by swagger) from the GiftAid IoC Module

- Story 3
	- I spent a long time attempting to serve up the existing swagger.yaml file as UI swagger documentation. I haven't yet suceeded
	- It felt weird to "regenerate" swagger.json off an api which was itself generated from a swagger.yaml
	- I do think serving the swagger.yaml file which already exists is possible, I just ended up down a bit of a rabbit hole
	- Additionally, the swagger 3.0 spec allows maximum and minimum values to be supplied to query paramaters. Despite this being added, the controller generation doesn't generate any validation.
		Indeed there appear to be a few short-coming using this generation mechanism. https://github.com/RicoSuter/NSwag/issues/1955
	- I'm wondering if I've taken "use swagger spec as the basis for your API" a little to literally. Perhaps I shouldn't be re-generating the controllers based on swagger
	- I ended up going down a *huge* nswag rabbit hole. Learned a lot. nswag.json now allows us to generate controllers with ActionResult return types, allowing for a decent response to go back to the client on validation.
	- Considering if it would have been better to create a web-api project rather than keep the MVC one as part of the submission.

- Story 4.1
	- Speccing new endpoint using swagger.yaml and auto-generating controller
	- I am *agonisingly close*. For some reason there isn't a good way to get a request object generated for the post request
		I've tried with both openApi 3 and swagger 2.0 to no avail. 
		Either I can generate a FromBody request object that isn't typed and lose my generated request resposne objects
		Or I can generate without a parameter in the new post endpoint
- Story 4.2
	- Using LiteDB for the first time is great!
	- Considering the possibility that we may want to able to identify "duplicate" gift aid declarations. 
		We don't have any concept of a CharityId as part of the declaration here, which we could use along with a time boundrary (of say 1 second)?
		I think an elegant solution with what we have would be to hash the Declaration fields along with the request time to deterministically create an identifier and ensure we don't persist duplicate requests
		As this hasn't been part of the exercise, I'll leave it as a stretch goal
	- My implementaion for now will use the same poco for the database and for exposure beyond the repository
		I do this with the awareness that it's poor practice to do so, i.e. if the document schema changes, a lot of code changes. But I have run well over of time 
		I would have
			- Created a "data store" class and interface
			- Interfaces with would expose a "public" DTO for a donation
			- The data store would make use of the IRepository and be responsible for the mapping between the repository object and the "public" DTO
			- I've simply run out of time to write the code for this and the associated tests.
			- Chosen ObjectId as the type for database document identifiers in LiteDb. However I didn't want LiteDb dependencies to exist on anything outside the repository. Hence use of a GUID
		The repository could also certainly be genericised.
- Story 4.3 
	- Made *some* progress with swagger - It turns out my use of NSWAG studio to help debug what was going on was putting an enitre JSON payload of our swagger.yaml insude the nswag.json, masking any further changes I'd made.'
		This caused a lot of problems and frustration
		In short, it seems that providing a path to swagger.yaml from configuration file such as nswag.json doesn't work when trying all the obvious things
		I've reverted to supplying paths on the command line and putting in the UseActionResult flag 
		Very glad I've gotten this working, but the majority of my time has been spent on this!
- Story 4.4
	- With hindsight, could have used Fluent Validation for validating request payloads earlier on, instead of hand-cranking a validator.
		This would have been much nicer, though perhaps would offer less "injectible config"
		With more time, I would have gona back and changed this.
	- Used FluentValidation for the GiftAidDeclaration endpoint. 
		Auto-generating those controllers has resulted in further problems with not being able to access ModelState in the controller
		Re-generating as an abstract class allowed me to now use the model state. Small annoyance of losing the Async suffix to the methods.
		I actually think this is much cleaner and clearer. [ApiController] annotation makes things lovely
